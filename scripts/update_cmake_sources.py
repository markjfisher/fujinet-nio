#!/usr/bin/env python3
import os
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]  # assuming scripts/ under repo root
SRC_ROOT = REPO_ROOT / "src"
BUILD_ARTIFACTS = REPO_ROOT / "build-artifacts"

POSIX_CMAKE_TEMPLATE = BUILD_ARTIFACTS / "CMakeLists_posix.cmake"
ESP32_CMAKE_TEMPLATE = BUILD_ARTIFACTS / "src" / "CMakeLists.txt"

POSIX_CMAKE = REPO_ROOT / "CMakeLists_posix.cmake"
ESP32_CMAKE = SRC_ROOT / "CMakeLists.txt"

START_MARKER = "# __TARGET_SOURCES_START__"
END_MARKER   = "# __TARGET_SOURCES_END__"

APP_START_MARKER = "# __POSIX_APP_SOURCES_START__"
APP_END_MARKER   = "# __POSIX_APP_SOURCES_END__"

GENERATED_COMMENT = "This file is automatically generated by scripts/update_cmake_sources.py\n# Do not edit this file directly. Edit the template in build-artifacts/ instead."


def collect_cpp_files():
    """Return all .cpp paths under src/ as POSIX-style strings."""
    files = []
    for root, _, filenames in os.walk(SRC_ROOT):
        for name in filenames:
            if not name.endswith(".cpp"):
                continue
            full = Path(root) / name
            rel = full.relative_to(REPO_ROOT)  # e.g. src/lib/foo.cpp
            files.append(rel.as_posix())
    return sorted(files)


def generate_posix_block(all_cpp):
    """
    Generate file paths for fujinet-nio (POSIX library target).
    Rules:
      - include src/lib/**.cpp and src/platform/posix/**.cpp (and any other non-app, non-esp32 .cpp)
      - exclude anything under src/app/**
      - exclude anything under src/platform/esp32/**
    Additionally:
      - legacy transport sources are only added when FN_ENABLE_LEGACY_TRANSPORT is ON (via generator expressions).
    Returns only the file paths with proper indentation (8 spaces).
    """
    filtered = []
    for path in all_cpp:
        # Exclude all app sources from the library
        if path.startswith("src/app/"):
            continue
        # Exclude ESP32 platform sources
        if "/platform/esp32/" in path:
            continue
        filtered.append(path)

    def is_legacy_source(p: str) -> bool:
        if p.startswith("src/lib/transport/legacy/"):
            return True
        if p == "src/lib/legacy_network_adapter.cpp":
            return True
        if p in (
            "src/platform/posix/sio_bus_hardware.cpp",
            "src/platform/posix/iwm_bus_hardware.cpp",
            "src/platform/posix/netsio_bus_hardware.cpp",
            "src/platform/posix/udp_channel.cpp",
        ):
            return True
        return False

    lines = []
    for p in filtered:
        if is_legacy_source(p):
            lines.append(f"        $<$<BOOL:${{FN_ENABLE_LEGACY_TRANSPORT}}>:{p}>")
        else:
            lines.append(f"        {p}")
    return "\n".join(lines) + "\n" if lines else "\n"


def generate_posix_app_block(all_cpp):
    """
    Generate file paths for the fujinet-nio-posix executable target.
    Rules:
      - include src/app/**.cpp
      - exclude src/app/main_esp32.cpp
      - exclude src/app/main_posix.cpp (already in add_executable)
    Returns only the file paths with proper indentation (12 spaces).
    """
    filtered = []
    for path in all_cpp:
        if not path.startswith("src/app/"):
            continue
        if path == "src/app/main_esp32.cpp":
            continue
        # We already list main_posix.cpp in add_executable(), so skip it here
        if path == "src/app/main_posix.cpp":
            continue
        filtered.append(path)

    lines = []
    for path in filtered:
        lines.append(f"            {path}")
    return "\n".join(lines) + "\n" if lines else "\n"


def generate_esp32_block(all_cpp):
    """
    Generate the idf_component_register() SRCS list block for ESP-IDF (src/CMakeLists.txt).
    Rules:
      - paths relative to src/ (no leading 'src/')
      - include app/main_esp32.cpp
      - exclude app/main_posix.cpp
      - exclude platform/posix/*
    Additionally:
      - legacy transport sources are only added when FN_ENABLE_LEGACY_TRANSPORT is ON (via generator expressions).
    """
    filtered = []
    for path in all_cpp:
        if path == "src/app/main_posix.cpp":
            continue
        if "/platform/posix/" in path:
            continue
        # keep everything else (libs + platform/esp32 + app/main_esp32)
        if path.startswith("src/"):
            rel = path[len("src/"):]  # strip src/ prefix
        else:
            rel = path
        filtered.append(rel)

    def is_legacy_source(p: str) -> bool:
        if p.startswith("lib/transport/legacy/"):
            return True
        if p == "lib/legacy_network_adapter.cpp":
            return True
        if p in (
            "platform/esp32/sio_bus_hardware.cpp",
            "platform/esp32/iwm_bus_hardware.cpp",
        ):
            return True
        return False

    lines = []
    for p in filtered:
        if is_legacy_source(p):
            lines.append(
                f"        $<$<OR:$<BOOL:${{FN_BUILD_ATARI_SIO}}>,"
                f"$<BOOL:${{FN_BUILD_ATARI_NETSIO}}>>:{p}>"
            )
        else:
            lines.append(f"        {p}")
    return "\n".join(lines) + "\n"


def replace_block_in_file(path: Path, start_marker: str, end_marker: str, new_block: str):
    text = path.read_text(encoding="utf-8")

    try:
        start_idx = text.index(start_marker)
        end_idx = text.index(end_marker)
    except ValueError:
        raise SystemExit(f"Markers not found in {path}")

    before = text[:start_idx + len(start_marker)]
    after = text[end_idx:]

    replaced = before + "\n" + new_block + end_marker + after.split(end_marker, 1)[1]
    path.write_text(replaced, encoding="utf-8")
    print(f"Updated {path}")


def copy_template_and_replace_comment(template_path: Path, output_path: Path):
    """Copy template file and replace __GENERATED_COMMENT__ with actual comment."""
    content = template_path.read_text(encoding="utf-8")
    content = content.replace("__GENERATED_COMMENT__", GENERATED_COMMENT)
    output_path.write_text(content, encoding="utf-8")
    print(f"Copied template {template_path} -> {output_path}")


def main():
    all_cpp = collect_cpp_files()

    # Copy templates to output locations
    copy_template_and_replace_comment(POSIX_CMAKE_TEMPLATE, POSIX_CMAKE)
    copy_template_and_replace_comment(ESP32_CMAKE_TEMPLATE, ESP32_CMAKE)

    # Generate source blocks
    posix_block = generate_posix_block(all_cpp)
    posix_app_block = generate_posix_app_block(all_cpp)
    esp32_block = generate_esp32_block(all_cpp)

    # Update POSIX CMake with library sources
    replace_block_in_file(POSIX_CMAKE, START_MARKER, END_MARKER, posix_block)
    # Update POSIX CMake with app sources
    replace_block_in_file(POSIX_CMAKE, APP_START_MARKER, APP_END_MARKER, posix_app_block)

    # Update ESP32 CMake
    replace_block_in_file(ESP32_CMAKE, START_MARKER, END_MARKER, esp32_block)


if __name__ == "__main__":
    main()
